# -*- coding: utf-8 -*-
"""face_recog_JBK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EXT9ZVvbhduFmYx02SVOap-7vzwFKDM6

# Custom Model 1
"""

import numpy as np
import os
import tensorflow as tf
import cv2
from IPython.display import display, Image
import io
from tensorflow.keras.models import load_model, Model
from tensorflow.keras.preprocessing import image
import pickle

inv_map = None
with open("inverse_mapping.pkl", "rb") as file:
    inv_map = pickle.load(file)
    print(inv_map)
with open("y_data.npy", "rb") as file:
    # Load the content using numpy's load function
    content = np.load(file)
    print(content)

model = load_model('model_weights3.h5')
new_model = Model(inputs=model.input, outputs=model.layers[-5].output)
# Load weights only till the last three layers
new_model.load_weights('model_weights3.h5', by_name=True)
# print(new_model.summary())
# predictions = new_model.predict(img_array)
# print(predictions.shape)
import cv2
def preprocess_image(img_path):
    try:
        print(f"Processing image at: {img_path}")
        img = cv2.imread(img_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert to RGB
        img = cv2.resize(img, (224, 224))  # Resize the image
        img_array = img / 255.0
        img_array = tf.expand_dims(img_array, 0)  # Add a batch dimension
        return img_array
    except Exception as e:
        print(f"Error processing image at {img_path}: {e}")
        return None
    # except Exception as e:
    #     print(f"Error processing image at {img_path}: {e}")
    #     return None

# Function to compute the Euclidean distance between two embeddings
def euclidean_distance(vects):
    x, y = vects
    sum_square = tf.reduce_sum(tf.square(x - y), axis=1, keepdims=True)
    return tf.sqrt(tf.maximum(sum_square, tf.keras.backend.epsilon()))

# Function to check redundancy using Siamese network
def check_redundancy(base_image_path, other_image_paths, model):
    # Preprocess the base image
    base_img_array = preprocess_image(base_image_path)
    base_embedding = model.predict(base_img_array)

    # Store distances
    distances = []

    for image_path in other_image_paths:
        # Preprocess other images
        other_img_array = preprocess_image(image_path)
        other_embedding = model.predict(other_img_array)

        # Compute the Euclidean distance between the embeddings
        distance = euclidean_distance([base_embedding, other_embedding])
        distances.append(distance.numpy())

    return distances

# Example usage
# Get a list of other image paths
import os
base_image_path = 'images_dataset_rns/Manu/Snapchat-1109357095.jpg'
main_folder = 'images_dataset_rns/Manu/fotor_1700416953097.jpg'

# Get a list of other image paths
#other_image_paths = []

distance = check_redundancy(base_image_path, main_folder, new_model)
            # Check redundancy and accumulate distances
print(f"Distance between {base_image_path} and {main_folder}: {distance}")
