# -*- coding: utf-8 -*-
"""face_recog_JBK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EXT9ZVvbhduFmYx02SVOap-7vzwFKDM6

# Custom Model 1
"""

import numpy as np
import os
import tensorflow as tf
import cv2
from IPython.display import display, Image
import io
from tensorflow.keras.models import load_model, Model
from tensorflow.keras.preprocessing import image
import pickle

inv_map = None
with open("inverse_mapping.pkl", "rb") as file:
    inv_map = pickle.load(file)
    print(inv_map)
with open("y_data.npy", "rb") as file:
    # Load the content using numpy's load function
    content = np.load(file)
    print(content)

model = load_model('model_weights3.h5')
new_model = Model(inputs=model.input, outputs=model.layers[-5].output)
# Load weights only till the last three layers
new_model.load_weights('model_weights3.h5', by_name=True)
# print(new_model.summary())
# predictions = new_model.predict(img_array)
# print(predictions.shape)
def preprocess_image(img_path):
    img = cv2.imread(img_path)
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = img_array / 255.0
    img_array = tf.expand_dims(img_array, 0)  # Add a batch dimension
    return img_array

# Function to compute the Euclidean distance between two embeddings
def euclidean_distance(vects):
    x, y = vects
    sum_square = tf.reduce_sum(tf.square(x - y), axis=1, keepdims=True)
    return tf.sqrt(tf.maximum(sum_square, tf.keras.backend.epsilon()))

# Function to check redundancy using Siamese network
def check_redundancy(base_image_path, other_image_paths, model):
    # Preprocess the base image
    base_img_array = preprocess_image(base_image_path)
    base_embedding = model.predict(base_img_array)

    # Store distances
    distances = []

    for image_path in other_image_paths:
        # Preprocess other images
        other_img_array = preprocess_image(image_path)
        other_embedding = model.predict(other_img_array)

        # Compute the Euclidean distance between the embeddings
        distance = euclidean_distance([base_embedding, other_embedding])
        distances.append(distance.numpy())

    return distances

# Example usage
base_image_path = 'images/170f892c-6f12-11ec-90fd-dc4af0b7c0b9_1641488553386.jpg'
other_image_folder = 'images/' 
# Get a list of other image paths
other_image_paths = [os.path.join(other_image_folder, filename) for filename in os.listdir(other_image_folder)]

# Check redundancy and get distances
distances = check_redundancy(base_image_path, other_image_paths, new_model)

# Print distances
for i, distance in enumerate(distances):
    print(f"Distance between image and image_{i}: {distance}")